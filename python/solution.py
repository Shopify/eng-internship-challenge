#!/usr/bin/env python3
class PlayfairCipher:
    # Representation Invariants:
    # -Both keyword and message should be non-empty strings.
    # -The characters in keyword and message should only contain
    #  uppercase alphabets.
    def __init__(self, keyword, message):
        self.keyword = keyword
        self.message = message

    # Returns the formatted decoded message as a string using the Playfair Cipher rules and the constructed matrix.
    #
    # Representation Invariants:
    #     The matrix contains only uppercase alphabets excluding J and X.
    def decode(self):
        msg = self.format()
        matrix = self.matrixcons()
        encode = []

        i = 0
        for x in msg:
            cx1 = self.indexing(x[0], matrix)
            cx2 = self.indexing(x[1], matrix)
            if cx1[0] == cx2[0]:
                encode.append(self.rule2(i)[0])
                encode.append(self.rule2(i)[1])
            elif cx1[1] == cx2[1]:
                encode.append(self.rule1(i)[0])
                encode.append(self.rule1(i)[1])
            else:
                encode.append(self.rule3(i)[0])
                encode.append(self.rule3(i)[1])
            i += 1

        stringEncode = ''
        for x in encode:
            if x != 'X':
                stringEncode += x
        return stringEncode

    # Returns a simplified version of the keyword by removing duplicate characters.
    #
    # Rep Invariants:
    # The returned key list should only contain uppercase alphabets.

    def simplekey(self):
        key = []
        for x in self.keyword:
            if x == 'J':
                x = 'I'
            if x not in key:
                key.append(x)
        return key

    # Returns the Playfair matrix based on the simplified keyword and remaining unused alphabets.
    #
    # Representation Invariants:
    #     The constructed matrix should be a 5x5 grid containing unique uppercase alphabets (excluding 'J').
    #     Each character in the matrix should appear only once.
    def matrixcons(self):
        key = self.simplekey()
        alphabets = 'ABCDEFGHIKLMNOPQRSTUVWXYZ'

        removedAlpha = ''
        for x in alphabets:
            if x not in key:
                removedAlpha += x

        row = 5
        column = 5

        matrix = []
        counter = 0
        k = 0
        for i in range(row):
            a = []
            for j in range(column):
                if counter >= len(key):
                    a.append(removedAlpha[k])
                    k += 1
                else:
                    a.append(key[counter])
                counter += 1
            matrix.append(a)
        return matrix

    # Requires a character string and a Playfair matrix.
    # Returns the row and column indices of the character in the matrix as a list.
    #
    # Representation Invariants:
    #    The input string should be a single uppercase alphabet.
    #    The matrix should be a valid Playfair matrix as generated by the matrixcons method.
    @staticmethod
    def indexing(string, matrix):

        if string == 'J':
            string = 'I'

        i = 0
        index = []
        for x in matrix:
            j = 0
            for y in x:
                if y == string:
                    index.append(i)
                    index.append(j)
                    break
                j += 1
            else:
                i += 1
                continue
            break

        return index

    # Returns the message into list of pairs of characters according to Playfair Cipher rules.
    #
    # Representation Invariants:
    #     The input message should be a non-empty string containing only uppercase alphabets (excluding 'J').
    def format(self):
        pairList = []
        j = 0
        size = len(self.message)
        while j < size:
            a = []
            for i in range(2):
                if (j + 1) >= size:
                    a.append(self.message[j])
                    a.append('X')
                    break
                elif self.message[j] == self.message[j + 1]:
                    a.append(self.message[j])
                    a.append('X')
                    j -= 1
                    break
                else:
                    a.append(self.message[j + i])
            pairList.append(a)
            j += 2

        return pairList

    # Requires a specified index in the formatted message.
    # Returns the transformed characters based on the rule of what happens
    # when the characters are in the same column as a list.
    #
    # Representation Invariants:
    #     The input index should be a valid index within the formatted message list.
    def rule1(self, index):
        formatMsg = self.format()[index]
        matrix = self.matrixcons()

        cx1 = self.indexing(formatMsg[0], matrix)
        cx2 = self.indexing(formatMsg[1], matrix)

        down1 = ''
        down2 = ''
        if cx1[0] == 4:
            down1 = matrix[0][cx1[1]]
        else:
            down1 = matrix[cx1[0] + 1][cx1[1]]
        if cx2[0] == 4:
            down2 = matrix[0][cx1[1]]
        else:
            down2 = matrix[cx2[0] + 1][cx2[1]]

        formatMsg = [down1, down2]

        return formatMsg

    # Requires a specified index in the formatted message.
    # Returns the transformed characters based on the rule of what happens
    # when the characters are in the same row as a list.
    #
    # Representation Invariants:
    #     The input index should be a valid index within the formatted message list.
    def rule2(self, index):
        formatMsg = self.format()[index]
        matrix = self.matrixcons()

        cx1 = self.indexing(formatMsg[0], matrix)
        cx2 = self.indexing(formatMsg[1], matrix)

        right1 = ''
        right2 = ''
        if cx1[1] == 0:
            right1 = matrix[cx1[0]][4]
        else:
            right1 = matrix[cx1[0]][cx1[1] - 1]
        if cx2[1] == 0:
            right2 = matrix[cx2[0]][4]
        else:
            right2 = matrix[cx2[0]][cx2[1] - 1]
        formatMsg = [right1, right2]

        return formatMsg

    # Requires a specified index in the formatted message.
    # Returns the transformed characters based on the rule of what happens
    # when the characters are in different row and column as a list.
    #
    # Representation Invariants:
    #     The input index should be a valid index within the formatted message list.
    def rule3(self, index):
        formatMsg = self.format()[index]
        matrix = self.matrixcons()

        cx1 = self.indexing(formatMsg[0], matrix)
        cx2 = self.indexing(formatMsg[1], matrix)
        corner1 = matrix[cx1[0]][cx2[1]]
        corner2 = matrix[cx2[0]][cx1[1]]
        formatMsg = [corner1, corner2]

        return formatMsg


if __name__ == '__main__':
    key = "SUPERSPY"
    encryptText = "IKEWENENXLNQLPZSLERUMRHEERYBOFNEINCHCV"
    decryption = PlayfairCipher(key, encryptText).decode()
    print(decryption)
# Playfair Cipher Decryption
# Written by: Vithun Vigneswaran

# Playfair Cipher Requirements:
# 1. The key table is a 5x5 matrix of characters
# 2. The key is used to generate the key table
# 3. The key table is generated by adding the key to the table and then adding the remaining characters
# 4. The key table is used to encrypt and decrypt the message
# 5. The message is decrypted by pairing characters and applying the following rules:
#    a. If the characters are in the same row, replace them with the character to their right
#    b. If the characters are in the same column, replace them with the character below them
#    c. If the characters are in different rows and columns, replace them with the character in the same row but in the column of the other character


# Generate the key table from the key
def generate_key_table(key):
    alphabet = "ABCDEFGHIKLMNOPQRSTUVWXYZ"  # 'J' is excluded
    key = key.upper()
    key_table = [] # List to store
    used_chars = set() # Set to keep track of used characters
    pos_dict = {} # Dictionary to store the position of each character

    # Add the key to the key table
    for char in key:
        if char not in used_chars and char in alphabet:
            key_table.append(char)
            used_chars.add(char)

    # Add the remaining characters to the key table
    for char in alphabet:
        if char not in used_chars:
            key_table.append(char)
            used_chars.add(char)

    # Create position dictionary
    for index, char in enumerate(key_table):
        pos_dict[char] = (index // 5, index % 5) # (row, column)

    # Return the key table as a 5x5 matrix and position dictionary
    return [key_table[i * 5:(i + 1) * 5] for i in range(5)], pos_dict

# Preprocess the message
def preprocess_msg(msg):
    msg = msg.upper().replace("J", "I")  # Replace J with I
    processed_msg = []
    i = 0

    # Pair characters and add X if the message length is odd or characters are the same
    while i < len(msg):
        a = msg[i]
        b = 'X' if i + 1 == len(msg) else msg[i + 1]  # Add X if the message length is odd or characters are the same
        if a == b:
            processed_msg.append(a + 'X')
            i += 1
        else:
            processed_msg.append(a + b)
            i += 2

    return processed_msg

# Decrypt a pair of characters
def decrypt_pair(pair, key_table, pos_dict):
    a, b = pair
    a_row, a_col = pos_dict[a]
    b_row, b_col = pos_dict[b]
    
    if a_row == b_row: 
        return key_table[a_row][(a_col - 1) % 5] + key_table[b_row][(b_col - 1) % 5]
    # If the characters are in the same column
    elif a_col == b_col: 
        return key_table[(a_row - 1) % 5][a_col] + key_table[(b_row - 1) % 5][b_col]
    # If the characters are in different rows and columns
    else: 
        return key_table[a_row][b_col] + key_table[b_row][a_col]

# Decrypt the message
def playfair_decryption(msg, key):
    key_table, pos_dict = generate_key_table(key)
    processed_msg = preprocess_msg(msg)
    decrypted_msg = ""

    for pair in processed_msg:
        decrypted_msg += decrypt_pair(pair, key_table, pos_dict)

    return decrypted_msg.replace('X', '')

if __name__ == "__main__":
    encrypted_msg = "IKEWENENXLNQLPZSLERUMRHEERYBOFNEINCHCV"  # Encrypted message
    key = "SUPERSPY"  # Key
    print(playfair_decryption(encrypted_msg, key))